var fs = require('fs');
var pathModule = require('path');
var Minimize = require('minimize');
var html = require('htmlparser2');

var extend = require('./utils').extend;
var RegexpProcessor = require('./RegexpProcessor');

const STYLE_BEGIN = Buffer('styles:[\'');
const STYLE_END = Buffer('\']');

function escapeSingleQuotes(string) {
    const ESCAPING = {
        '\'': '\\\'',
        '\\': '\\\\',
        '\n': '\\n',
        '\r': '\\r',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029'
    };
    return string.replace(/['\\\n\r\u2028\u2029]/g, function (character) {
        return ESCAPING[character];
    });
}

var Angular1Processor = extend(RegexpProcessor, {
    init : function(config) {
        this._super.init(config);

        if (!this.config.minimize) {
            this.config.minimize = {};
        }
        this.minimizer = new Minimize(this.config.minimize);
        if (!this.config.minimize.parser) {
            this.minimizer.htmlparser = new html.Parser(
                new html.DomHandler(this.minimizer.emits('read')), {lowerCaseAttributeNames:false}
            );
        }

        if (!this.config.templateEncoding) {
            this.config.templateEncoding = 'utf-8';
        }
    },

    /**
     * @returns {String} pattern to search
     */
    getPattern : function() {
        //return '[\'"]?templateUrl[\'"]?[\\s]*:[\\s]*[\'"`]([^\'"`]+)[\'"`]';
		return '[\'"]?styleUrls[\'"]?[\\s]*:[\\s]*\\[[\\s]*[\'"`]([^\'"`]+)[\'"`]([\\s]*[,][\\s]*[\'"`]([^\'"`]+)[\'"`][\\s]*)*\\][\s]*';
    },

    /**
     * Find next "templateUrl:", and try to replace url with content if template available, less then maximum size.
     * This is recursive function: it call itself until one of two condition happens:
     * - error happened (error emitted in pipe and stop recursive calls)
     * - no 'templateUrl' left (call 'fileCallback' and stop recursive calls)
     *
     * @param {Object} fileContext source file content
     * @param {Object} match Regexp.exec result
     * @param {Function} cb to call after match replaced
     * @param {Function} onErr error handler
     */
    replaceMatch : function(fileContext, match, cb, onErr) {
        var relativeStylePaths = JSON.parse(match[0].substring(match[0].indexOf('[')).replace(/['"`]/g,'"'));
		var _this = this;
		var stylePaths = [];
		var styleContents = "";
		var embedTemplate = _this.embedTemplate.bind(_this);
		
		relativeStylePaths.forEach(function(relativeStylePath) {
			var stylePath = pathModule.join(fileContext.path, relativeStylePath);
			var warnNext = function(msg) {
				_this.logger.warn(msg);
				cb();
			}.bind(_this);
			var onError = _this.config.skipErrors ? warnNext : onErr;

			_this.logger.debug('script path: %s', stylePath);

			if (_this.config.maxSize) {
				var fileStat = fs.statSync(stylePath);
				if (fileStat && fileStat.size > _this.config.maxSize) {
					warnNext('script file "' + stylePath + '" exceeds configured max size "' + _this.config.maxSize + '" actual size is "' + fileStat.size + '"');
					return;
				}
			}
			stylePaths.push(stylePath);
		});

		var next = function(){
			var stylePath = stylePaths.shift();
			fs.readFile(stylePath, {encoding: _this.config.templateEncoding}, function(err, styleContent) {
				if (err) {
					onError('Can\'t read script file: "' + stylePath + '". Error details: ' + err);
					return;
				}
				styleContents = styleContents.concat(styleContent);
				if(stylePaths.length>0){
					next();
				} else {
					var styleBuffer = Buffer(escapeSingleQuotes(styleContents));
					cb(embedTemplate(match, styleBuffer));
				}
			});
		}
		next();
    },

    embedTemplate : function(match, styleBuffer) {
        return {
            start : match.index,
            length: match[0].length,
            replace: [STYLE_BEGIN, styleBuffer, STYLE_END]
        }
    }
});

module.exports = Angular1Processor;